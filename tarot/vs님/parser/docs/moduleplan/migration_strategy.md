# 타로 LangGraph 모듈화 마이그레이션 전략

## 📋 개요

이 문서는 `tarot_langgraph.py` 파일을 LangGraph 표준 구조에 맞게 모듈화하는 마이그레이션 전략을 설명합니다. 기존 코드의 기능을 100% 유지하면서 점진적으로 모듈화를 진행합니다.

## 🔄 마이그레이션 원칙

1. **점진적 접근**: 한 번에 모든 것을 변경하지 않고 단계별로 진행
2. **기능 보존**: 각 단계마다 기능 테스트를 통해 원래 동작이 유지되는지 확인
3. **병렬 운영**: 마이그레이션 중에도 기존 코드를 유지하여 비교 및 롤백 가능성 확보
4. **의존성 최소화**: 모듈 간 의존성을 최소화하여 유지보수성 향상

## 🚀 마이그레이션 단계

### 1단계: 기본 구조 설정 및 상태 분리

**목표**: 기본 디렉토리 구조 생성 및 상태 정의 분리

1. 디렉토리 구조 생성
2. `state.py` 파일 생성 및 `TarotState` 클래스 이전
3. 기본 `__init__.py` 파일 생성
4. 임포트 테스트 진행

**테스트 방법**:
```python
# 테스트 스크립트
from parsing.parser.tarot_agent.utils.state import TarotState

# TarotState 클래스가 올바르게 정의되었는지 확인
print(TarotState.__annotations__)
```

### 2단계: 도구 및 유틸리티 함수 분리

**목표**: @tool 데코레이터 함수 및 주요 유틸리티 함수 분리

1. `tools.py` 파일 생성 및 @tool 데코레이터 함수 이전
2. `web_search.py`, `analysis.py` 등 유틸리티 파일 생성 및 관련 함수 이전
3. 임포트 구조 설정 및 테스트

**테스트 방법**:
```python
# 테스트 스크립트
from parsing.parser.tarot_agent.utils.tools import search_tarot_cards, search_tarot_spreads
from parsing.parser.tarot_agent.utils.web_search import perform_web_search

# 함수 기본 동작 테스트
result = search_tarot_cards("태양")
print(result)
```

### 3단계: 노드 함수 분리

**목표**: 그래프 노드 함수들 분리

1. `nodes.py` 파일 생성 및 모든 노드 함수 이전
2. 유틸리티 함수 임포트 구조 설정
3. 노드 함수 테스트

**테스트 방법**:
```python
# 테스트 스크립트
from parsing.parser.tarot_agent.utils.nodes import state_classifier_node
from parsing.parser.tarot_agent.utils.state import TarotState

# 기본 상태 생성
state = TarotState(
    messages=[],
    user_intent="unknown",
    user_input="타로 카드에 대해 알려주세요"
)

# 노드 함수 테스트
result = state_classifier_node(state)
print(result)
```

### 4단계: 그래프 구성 및 메인 실행 함수 분리

**목표**: 그래프 구성 및 메인 실행 함수 분리

1. `agent.py` 파일 생성 및 그래프 구성 함수 이전
2. 메인 실행 함수 이전
3. 전체 시스템 통합 테스트

**테스트 방법**:
```python
# 테스트 스크립트
from parsing.parser.tarot_agent.agent import create_optimized_tarot_graph

# 그래프 생성 테스트
graph = create_optimized_tarot_graph()
print("그래프 생성 성공!")
```

### 5단계: 통합 테스트 및 최적화

**목표**: 전체 시스템 통합 테스트 및 성능 최적화

1. 전체 시스템 통합 테스트 진행
2. 성능 측정 및 비교
3. 필요시 코드 최적화

**테스트 방법**:
```python
# 테스트 스크립트
from parsing.parser.tarot_agent.agent import main

# 메인 실행 함수 테스트
if __name__ == "__main__":
    main()
```

## 📊 테스트 전략

### 단위 테스트

각 모듈의 핵심 함수들에 대한 단위 테스트를 작성합니다:

1. **상태 테스트**: `TarotState` 클래스가 올바르게 정의되었는지 확인
2. **도구 테스트**: `search_tarot_cards`, `search_tarot_spreads` 등의 도구 함수 테스트
3. **유틸리티 테스트**: 주요 유틸리티 함수들의 기능 테스트
4. **노드 테스트**: 주요 노드 함수들의 입출력 테스트

### 통합 테스트

전체 시스템의 통합 테스트를 진행합니다:

1. **그래프 생성 테스트**: 그래프가 올바르게 생성되는지 확인
2. **엔드투엔드 테스트**: 사용자 입력부터 응답까지 전체 흐름 테스트
3. **에러 처리 테스트**: 다양한 예외 상황에서의 동작 테스트

### 성능 테스트

기존 코드와 모듈화된 코드의 성능을 비교합니다:

1. **응답 시간 측정**: 동일한 입력에 대한 응답 시간 비교
2. **메모리 사용량 측정**: 메모리 사용량 비교
3. **CPU 사용량 측정**: CPU 사용량 비교

## 🔍 잠재적 문제 및 해결 방안

### 1. 순환 참조 문제

**문제**: 모듈 간 상호 의존성으로 인한 순환 참조 발생

**해결 방안**:
- 함수 내부에서 필요한 모듈을 임포트하여 순환 참조 방지
- 함수 인자로 필요한 객체 전달
- 공통 의존성을 상위 모듈로 이동

### 2. 전역 변수 관리

**문제**: 여러 모듈에서 사용되는 전역 변수의 관리

**해결 방안**:
- 전역 변수를 적절한 모듈에 정의하고 필요한 곳에서 임포트
- 싱글톤 패턴 사용
- 상태 관리 클래스 도입

### 3. 임포트 경로 문제

**문제**: 복잡한 디렉토리 구조로 인한 임포트 경로 문제

**해결 방안**:
- 상대 경로 사용
- `sys.path` 조정
- `__init__.py` 파일에 편리한 임포트 제공

### 4. 기능 호환성 문제

**문제**: 모듈화 과정에서 기존 기능이 손상될 가능성

**해결 방안**:
- 단계별 테스트 진행
- 기존 코드와 병렬 운영
- 회귀 테스트 자동화

## 🔄 롤백 전략

마이그레이션 중 문제가 발생할 경우를 대비한 롤백 전략:

1. **단계별 백업**: 각 마이그레이션 단계마다 코드 백업
2. **병렬 운영**: 기존 코드를 유지하면서 새 코드 개발
3. **기능 플래그**: 필요시 기존 코드와 새 코드를 전환할 수 있는 플래그 도입

## 📅 마이그레이션 일정

| 단계 | 작업 내용 | 예상 소요 시간 | 테스트 방법 |
|------|----------|--------------|------------|
| 1단계 | 기본 구조 설정 및 상태 분리 | 1일 | 임포트 테스트 |
| 2단계 | 도구 및 유틸리티 함수 분리 | 2일 | 함수 기능 테스트 |
| 3단계 | 노드 함수 분리 | 1일 | 노드 기능 테스트 |
| 4단계 | 그래프 구성 및 메인 실행 함수 분리 | 1일 | 그래프 생성 테스트 |
| 5단계 | 통합 테스트 및 최적화 | 2일 | 전체 시스템 테스트 |

## 📊 성공 지표

마이그레이션 성공을 판단하기 위한 지표:

1. **기능 동일성**: 모든 기존 기능이 동일하게 작동
2. **성능 유지**: 응답 시간, 메모리 사용량 등이 기존과 동일하거나 개선
3. **코드 품질**: 모듈화된 코드의 가독성, 유지보수성 향상
4. **확장성**: 새로운 기능 추가가 용이한 구조

## 🚀 마이그레이션 후 계획

마이그레이션 완료 후 계획:

1. **문서화**: 모듈화된 코드에 대한 상세 문서 작성
2. **성능 최적화**: 병목 지점 식별 및 최적화
3. **기능 확장**: 새로운 기능 추가
4. **테스트 자동화**: 자동화된 테스트 구축 